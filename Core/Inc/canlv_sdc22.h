/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-2019 Erik Moqvist
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * This file was generated by cantools version 38.0.2 Thu Jul 27 14:47:09 2023.
 */

#ifndef CANLV_SDC22_H
#define CANLV_SDC22_H

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

#ifndef EINVAL
#    define EINVAL 22
#endif

/* Frame ids. */
#define CANLV_SDC22_DSPACE_ACK_RTD_FRAME_ID (0x40u)
#define CANLV_SDC22_DSPACE_PWM_COOLING_FRAME_ID (0x41u)
#define CANLV_SDC22_DASH_CMD_RTD_FRAME_ID (0x42u)
#define CANLV_SDC22_SENSORBOARD_ADC_0_3_FRAME_ID (0x10u)
#define CANLV_SDC22_SENSORBOARD_ADC_4_7_FRAME_ID (0x11u)
#define CANLV_SDC22_SENSORBOARD_ADC_8_11_FRAME_ID (0x12u)
#define CANLV_SDC22_SENSORBOARD_ADC_12_15_FRAME_ID (0x13u)
#define CANLV_SDC22_SENSORBOARD_ADC_16_19_FRAME_ID (0x14u)
#define CANLV_SDC22_SENSORBOARD_PING_FRAME_ID (0x01u)
#define CANLV_SDC22_DASH_TIMER_FRAME_ID (0x04u)
#define CANLV_SDC22_DASH_STATUS_FRAME_ID (0x45u)
#define CANLV_SDC22_DSPACE_DASH_TIMER_FRAME_ID (0x43u)

/* Frame lengths in bytes. */
#define CANLV_SDC22_DSPACE_ACK_RTD_LENGTH (1u)
#define CANLV_SDC22_DSPACE_PWM_COOLING_LENGTH (3u)
#define CANLV_SDC22_DASH_CMD_RTD_LENGTH (1u)
#define CANLV_SDC22_SENSORBOARD_ADC_0_3_LENGTH (8u)
#define CANLV_SDC22_SENSORBOARD_ADC_4_7_LENGTH (8u)
#define CANLV_SDC22_SENSORBOARD_ADC_8_11_LENGTH (8u)
#define CANLV_SDC22_SENSORBOARD_ADC_12_15_LENGTH (8u)
#define CANLV_SDC22_SENSORBOARD_ADC_16_19_LENGTH (8u)
#define CANLV_SDC22_SENSORBOARD_PING_LENGTH (1u)
#define CANLV_SDC22_DASH_TIMER_LENGTH (4u)
#define CANLV_SDC22_DASH_STATUS_LENGTH (6u)
#define CANLV_SDC22_DSPACE_DASH_TIMER_LENGTH (2u)

/* Extended or standard frame types. */
#define CANLV_SDC22_DSPACE_ACK_RTD_IS_EXTENDED (0)
#define CANLV_SDC22_DSPACE_PWM_COOLING_IS_EXTENDED (0)
#define CANLV_SDC22_DASH_CMD_RTD_IS_EXTENDED (0)
#define CANLV_SDC22_SENSORBOARD_ADC_0_3_IS_EXTENDED (0)
#define CANLV_SDC22_SENSORBOARD_ADC_4_7_IS_EXTENDED (0)
#define CANLV_SDC22_SENSORBOARD_ADC_8_11_IS_EXTENDED (0)
#define CANLV_SDC22_SENSORBOARD_ADC_12_15_IS_EXTENDED (0)
#define CANLV_SDC22_SENSORBOARD_ADC_16_19_IS_EXTENDED (0)
#define CANLV_SDC22_SENSORBOARD_PING_IS_EXTENDED (0)
#define CANLV_SDC22_DASH_TIMER_IS_EXTENDED (0)
#define CANLV_SDC22_DASH_STATUS_IS_EXTENDED (0)
#define CANLV_SDC22_DSPACE_DASH_TIMER_IS_EXTENDED (0)

/* Frame cycle times in milliseconds. */


/* Signal choices. */
#define CANLV_SDC22_DSPACE_ACK_RTD_ACK_CTOR_EN__ACKNOLEDGE_CHOICE (1u)
#define CANLV_SDC22_DSPACE_ACK_RTD_ACK_RTD__ACKNOWLEDGE_CHOICE (2u)
#define CANLV_SDC22_DSPACE_ACK_RTD_ACK_CONTACTORS_OPENED_ACKNOWLEDGE_CHOICE (3u)

#define CANLV_SDC22_DASH_CMD_RTD_DASH_BUTTON_ACTIVATE__CONTACTOR_ENABLE_CHOICE (1u)
#define CANLV_SDC22_DASH_CMD_RTD_DASH_BUTTON_ACTIVATE__READY_TO_DRIVE_CHOICE (2u)

#define CANLV_SDC22_DASH_STATUS_RTD_FSM_STATUS_IDLE_CHOICE (0u)
#define CANLV_SDC22_DASH_STATUS_RTD_FSM_STATUS_CTOR_EN_CHOICE (1u)
#define CANLV_SDC22_DASH_STATUS_RTD_FSM_STATUS_WAIT_CTOR_EN_ACT_CHOICE (2u)
#define CANLV_SDC22_DASH_STATUS_RTD_FSM_STATUS_RTD_EN_CHOICE (3u)
#define CANLV_SDC22_DASH_STATUS_RTD_FSM_STATUS_WAIT_RTD_EN_ACK_CHOICE (4u)
#define CANLV_SDC22_DASH_STATUS_RTD_FSM_STATUS_RTD_CHOICE (5u)
#define CANLV_SDC22_DASH_STATUS_RTD_FSM_STATUS_STOP_CHOICE (6u)

#define CANLV_SDC22_DSPACE_DASH_TIMER_CMD_COUNT0_RESET_CHOICE (70u)
#define CANLV_SDC22_DSPACE_DASH_TIMER_CMD_COUNT0_READ_CHOICE (255u)

#define CANLV_SDC22_DSPACE_DASH_TIMER_CMD_COUNT1_RESET_CHOICE (70u)
#define CANLV_SDC22_DSPACE_DASH_TIMER_CMD_COUNT1_READ_CHOICE (254u)

/**
 * Signals in message DSPACE_ACK_RTD.
 *
 * All signal values are as on the CAN bus.
 */
struct canlv_sdc22_dspace_ack_rtd_t {
    /**
     * Feedback of the dash button
     * 1= contactor enable active
     * 2=ready to drive active
     * 3=contactor opened
     *
     * Range: 1..2 (1..2 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ack;
};

/**
 * Signals in message DSPACE_PWM_COOLING.
 *
 * All signal values are as on the CAN bus.
 */
struct canlv_sdc22_dspace_pwm_cooling_t {
    /**
     * Range: 0..100 (0..100 PWM)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pwm_pump;

    /**
     * Range: 0..100 (0..100 PWM)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pwm_rad_fan;

    /**
     * Range: 0..100 (0..100 PWM)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pwm_bp_fan;
};

/**
 * Signals in message DASH_CMD_RTD.
 *
 * All signal values are as on the CAN bus.
 */
struct canlv_sdc22_dash_cmd_rtd_t {
    /**
     * 
     *
     * Range: 1..2 (1..2 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dash_button;
};

/**
 * Signals in message SENSORBOARD_ADC_0_3.
 *
 * All signal values are as on the CAN bus.
 */
struct canlv_sdc22_sensorboard_adc_0_3_t {
    /**
     * Range: 0..65535 (-128.6628..9229.7352 %)
     * Scale: 0.1428
     * Offset: -128.6628
     */
    uint16_t throttle1;

    /**
     * Range: 3130.252100840336134453781513..-25546.21848739495798319327731 (0..4095 %)
     * Scale: -0.1428
     * Offset: 447
     */
    uint16_t throttle2;

    /**
     * Range: 30303.03030303030303030303030..-526193.9393939393939393939394 (-100..1736.44 %)
     * Scale: -0.0033
     * Offset: 0
     */
    uint16_t brake_strain_gauge1;

    /**
     * Range: 30303.03030303030303030303030..-526195.4545454545454545454545 (-100..1736.445 %)
     * Scale: -0.0033
     * Offset: 0
     */
    uint16_t brake_strain_gauge2;
};

/**
 * Signals in message SENSORBOARD_ADC_4_7.
 *
 * All signal values are as on the CAN bus.
 */
struct canlv_sdc22_sensorboard_adc_4_7_t {
    /**
     * Range: 0..3354632.587859424920127795527 (0..4095 LSB)
     * Scale: 0.0012207
     * Offset: 0
     */
    uint16_t adc4;

    /**
     * Range: 0..3354632.587859424920127795527 (0..4095 LSB)
     * Scale: 0.0012207
     * Offset: 0
     */
    uint16_t adc5;

    /**
     * Range: 0..65535 (-199..5537.9339 deg)
     * Scale: 0.08754
     * Offset: -199
     */
    uint16_t steering_angle;

    /**
     * Range: 0..65535 (-9.5..1759.945 bar)
     * Scale: 0.027
     * Offset: -9.5
     */
    uint16_t brake_press_front;
};

/**
 * Signals in message SENSORBOARD_ADC_8_11.
 *
 * All signal values are as on the CAN bus.
 */
struct canlv_sdc22_sensorboard_adc_8_11_t {
    /**
     * Range: 0..3354632.587859424920127795527 (0..4095 LSB)
     * Scale: 0.0012207
     * Offset: 0
     */
    uint16_t adc8;

    /**
     * Range: 0..3354632.587859424920127795527 (0..4095 LSB)
     * Scale: 0.0012207
     * Offset: 0
     */
    uint16_t adc9;

    /**
     * Range: 0..3354632.587859424920127795527 (0..4095 LSB)
     * Scale: 0.0012207
     * Offset: 0
     */
    uint16_t adc10;

    /**
     * Range: 0..3354632.587859424920127795527 (0..4095 LSB)
     * Scale: 0.0012207
     * Offset: 0
     */
    uint16_t adc11;
};

/**
 * Signals in message SENSORBOARD_ADC_12_15.
 *
 * All signal values are as on the CAN bus.
 */
struct canlv_sdc22_sensorboard_adc_12_15_t {
    /**
     * Range: 0..3354632.587859424920127795527 (0..4095 LSB)
     * Scale: 0.0012207
     * Offset: 0
     */
    uint16_t adc12;

    /**
     * Range: 0..3354632.587859424920127795527 (0..4095 LSB)
     * Scale: 0.0012207
     * Offset: 0
     */
    uint16_t adc13;

    /**
     * Range: 0..3354632.587859424920127795527 (0..4095 LSB)
     * Scale: 0.0012207
     * Offset: 0
     */
    uint16_t adc14;

    /**
     * Range: 0..3354632.587859424920127795527 (0..4095 LSB)
     * Scale: 0.0012207
     * Offset: 0
     */
    uint16_t adc15;
};

/**
 * Signals in message SENSORBOARD_ADC_16_19.
 *
 * All signal values are as on the CAN bus.
 */
struct canlv_sdc22_sensorboard_adc_16_19_t {
    /**
     * Range: 0..3354632.587859424920127795527 (0..4095 LSB)
     * Scale: 0.0012207
     * Offset: 0
     */
    uint16_t adc16;

    /**
     * Range: 0..3354632.587859424920127795527 (0..4095 LSB)
     * Scale: 0.0012207
     * Offset: 0
     */
    uint16_t adc17;

    /**
     * Range: 0..3354632.587859424920127795527 (0..4095 LSB)
     * Scale: 0.0012207
     * Offset: 0
     */
    uint16_t adc18;

    /**
     * Range: 0..3354632.587859424920127795527 (0..4095 LSB)
     * Scale: 0.0012207
     * Offset: 0
     */
    uint16_t adc19;
};

/**
 * Signals in message SENSORBOARD_PING.
 *
 * All signal values are as on the CAN bus.
 */
struct canlv_sdc22_sensorboard_ping_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t sensorboard_on_ack;
};

/**
 * Signals in message DASH_TIMER.
 *
 * All signal values are as on the CAN bus.
 */
struct canlv_sdc22_dash_timer_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t dash_seconds;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t dash_minutes;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t dash_hours;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t dash_days;
};

/**
 * Signals in message DASH_STATUS.
 *
 * All signal values are as on the CAN bus.
 */
struct canlv_sdc22_dash_status_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t dash_on_ack;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t rtd_fsm_status;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t bms_led;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t nohv_led;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t imd_led;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t pwm_pump_ack;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t pwm_rad_fan_ack;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t pwm_bp_fan_ack;
};

/**
 * Signals in message DSPACE_DASH_TIMER.
 *
 * All signal values are as on the CAN bus.
 */
struct canlv_sdc22_dspace_dash_timer_t {
    /**
     * if 0xFF - Read
     * if 0x46 - Reset
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmd_count0;

    /**
     * if 0xFE - Read
     * if 0x46 - Reset
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmd_count1;
};

/**
 * Pack message DSPACE_ACK_RTD.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int canlv_sdc22_dspace_ack_rtd_pack(
    uint8_t *dst_p,
    const struct canlv_sdc22_dspace_ack_rtd_t *src_p,
    size_t size);

/**
 * Unpack message DSPACE_ACK_RTD.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int canlv_sdc22_dspace_ack_rtd_unpack(
    struct canlv_sdc22_dspace_ack_rtd_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t canlv_sdc22_dspace_ack_rtd_ack_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float canlv_sdc22_dspace_ack_rtd_ack_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool canlv_sdc22_dspace_ack_rtd_ack_is_in_range(uint8_t value);

/**
 * Pack message DSPACE_PWM_COOLING.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int canlv_sdc22_dspace_pwm_cooling_pack(
    uint8_t *dst_p,
    const struct canlv_sdc22_dspace_pwm_cooling_t *src_p,
    size_t size);

/**
 * Unpack message DSPACE_PWM_COOLING.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int canlv_sdc22_dspace_pwm_cooling_unpack(
    struct canlv_sdc22_dspace_pwm_cooling_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t canlv_sdc22_dspace_pwm_cooling_pwm_pump_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float canlv_sdc22_dspace_pwm_cooling_pwm_pump_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool canlv_sdc22_dspace_pwm_cooling_pwm_pump_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t canlv_sdc22_dspace_pwm_cooling_pwm_rad_fan_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float canlv_sdc22_dspace_pwm_cooling_pwm_rad_fan_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool canlv_sdc22_dspace_pwm_cooling_pwm_rad_fan_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t canlv_sdc22_dspace_pwm_cooling_pwm_bp_fan_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float canlv_sdc22_dspace_pwm_cooling_pwm_bp_fan_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool canlv_sdc22_dspace_pwm_cooling_pwm_bp_fan_is_in_range(uint8_t value);

/**
 * Pack message DASH_CMD_RTD.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int canlv_sdc22_dash_cmd_rtd_pack(
    uint8_t *dst_p,
    const struct canlv_sdc22_dash_cmd_rtd_t *src_p,
    size_t size);

/**
 * Unpack message DASH_CMD_RTD.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int canlv_sdc22_dash_cmd_rtd_unpack(
    struct canlv_sdc22_dash_cmd_rtd_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t canlv_sdc22_dash_cmd_rtd_dash_button_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float canlv_sdc22_dash_cmd_rtd_dash_button_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool canlv_sdc22_dash_cmd_rtd_dash_button_is_in_range(uint8_t value);

/**
 * Pack message SENSORBOARD_ADC_0_3.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int canlv_sdc22_sensorboard_adc_0_3_pack(
    uint8_t *dst_p,
    const struct canlv_sdc22_sensorboard_adc_0_3_t *src_p,
    size_t size);

/**
 * Unpack message SENSORBOARD_ADC_0_3.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int canlv_sdc22_sensorboard_adc_0_3_unpack(
    struct canlv_sdc22_sensorboard_adc_0_3_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t canlv_sdc22_sensorboard_adc_0_3_throttle1_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float canlv_sdc22_sensorboard_adc_0_3_throttle1_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool canlv_sdc22_sensorboard_adc_0_3_throttle1_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t canlv_sdc22_sensorboard_adc_0_3_throttle2_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float canlv_sdc22_sensorboard_adc_0_3_throttle2_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool canlv_sdc22_sensorboard_adc_0_3_throttle2_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t canlv_sdc22_sensorboard_adc_0_3_brake_strain_gauge1_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float canlv_sdc22_sensorboard_adc_0_3_brake_strain_gauge1_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool canlv_sdc22_sensorboard_adc_0_3_brake_strain_gauge1_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t canlv_sdc22_sensorboard_adc_0_3_brake_strain_gauge2_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float canlv_sdc22_sensorboard_adc_0_3_brake_strain_gauge2_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool canlv_sdc22_sensorboard_adc_0_3_brake_strain_gauge2_is_in_range(uint16_t value);

/**
 * Pack message SENSORBOARD_ADC_4_7.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int canlv_sdc22_sensorboard_adc_4_7_pack(
    uint8_t *dst_p,
    const struct canlv_sdc22_sensorboard_adc_4_7_t *src_p,
    size_t size);

/**
 * Unpack message SENSORBOARD_ADC_4_7.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int canlv_sdc22_sensorboard_adc_4_7_unpack(
    struct canlv_sdc22_sensorboard_adc_4_7_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t canlv_sdc22_sensorboard_adc_4_7_adc4_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float canlv_sdc22_sensorboard_adc_4_7_adc4_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool canlv_sdc22_sensorboard_adc_4_7_adc4_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t canlv_sdc22_sensorboard_adc_4_7_adc5_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float canlv_sdc22_sensorboard_adc_4_7_adc5_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool canlv_sdc22_sensorboard_adc_4_7_adc5_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t canlv_sdc22_sensorboard_adc_4_7_steering_angle_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float canlv_sdc22_sensorboard_adc_4_7_steering_angle_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool canlv_sdc22_sensorboard_adc_4_7_steering_angle_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t canlv_sdc22_sensorboard_adc_4_7_brake_press_front_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float canlv_sdc22_sensorboard_adc_4_7_brake_press_front_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool canlv_sdc22_sensorboard_adc_4_7_brake_press_front_is_in_range(uint16_t value);

/**
 * Pack message SENSORBOARD_ADC_8_11.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int canlv_sdc22_sensorboard_adc_8_11_pack(
    uint8_t *dst_p,
    const struct canlv_sdc22_sensorboard_adc_8_11_t *src_p,
    size_t size);

/**
 * Unpack message SENSORBOARD_ADC_8_11.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int canlv_sdc22_sensorboard_adc_8_11_unpack(
    struct canlv_sdc22_sensorboard_adc_8_11_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t canlv_sdc22_sensorboard_adc_8_11_adc8_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float canlv_sdc22_sensorboard_adc_8_11_adc8_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool canlv_sdc22_sensorboard_adc_8_11_adc8_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t canlv_sdc22_sensorboard_adc_8_11_adc9_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float canlv_sdc22_sensorboard_adc_8_11_adc9_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool canlv_sdc22_sensorboard_adc_8_11_adc9_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t canlv_sdc22_sensorboard_adc_8_11_adc10_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float canlv_sdc22_sensorboard_adc_8_11_adc10_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool canlv_sdc22_sensorboard_adc_8_11_adc10_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t canlv_sdc22_sensorboard_adc_8_11_adc11_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float canlv_sdc22_sensorboard_adc_8_11_adc11_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool canlv_sdc22_sensorboard_adc_8_11_adc11_is_in_range(uint16_t value);

/**
 * Pack message SENSORBOARD_ADC_12_15.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int canlv_sdc22_sensorboard_adc_12_15_pack(
    uint8_t *dst_p,
    const struct canlv_sdc22_sensorboard_adc_12_15_t *src_p,
    size_t size);

/**
 * Unpack message SENSORBOARD_ADC_12_15.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int canlv_sdc22_sensorboard_adc_12_15_unpack(
    struct canlv_sdc22_sensorboard_adc_12_15_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t canlv_sdc22_sensorboard_adc_12_15_adc12_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float canlv_sdc22_sensorboard_adc_12_15_adc12_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool canlv_sdc22_sensorboard_adc_12_15_adc12_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t canlv_sdc22_sensorboard_adc_12_15_adc13_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float canlv_sdc22_sensorboard_adc_12_15_adc13_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool canlv_sdc22_sensorboard_adc_12_15_adc13_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t canlv_sdc22_sensorboard_adc_12_15_adc14_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float canlv_sdc22_sensorboard_adc_12_15_adc14_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool canlv_sdc22_sensorboard_adc_12_15_adc14_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t canlv_sdc22_sensorboard_adc_12_15_adc15_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float canlv_sdc22_sensorboard_adc_12_15_adc15_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool canlv_sdc22_sensorboard_adc_12_15_adc15_is_in_range(uint16_t value);

/**
 * Pack message SENSORBOARD_ADC_16_19.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int canlv_sdc22_sensorboard_adc_16_19_pack(
    uint8_t *dst_p,
    const struct canlv_sdc22_sensorboard_adc_16_19_t *src_p,
    size_t size);

/**
 * Unpack message SENSORBOARD_ADC_16_19.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int canlv_sdc22_sensorboard_adc_16_19_unpack(
    struct canlv_sdc22_sensorboard_adc_16_19_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t canlv_sdc22_sensorboard_adc_16_19_adc16_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float canlv_sdc22_sensorboard_adc_16_19_adc16_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool canlv_sdc22_sensorboard_adc_16_19_adc16_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t canlv_sdc22_sensorboard_adc_16_19_adc17_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float canlv_sdc22_sensorboard_adc_16_19_adc17_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool canlv_sdc22_sensorboard_adc_16_19_adc17_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t canlv_sdc22_sensorboard_adc_16_19_adc18_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float canlv_sdc22_sensorboard_adc_16_19_adc18_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool canlv_sdc22_sensorboard_adc_16_19_adc18_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t canlv_sdc22_sensorboard_adc_16_19_adc19_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float canlv_sdc22_sensorboard_adc_16_19_adc19_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool canlv_sdc22_sensorboard_adc_16_19_adc19_is_in_range(uint16_t value);

/**
 * Pack message SENSORBOARD_PING.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int canlv_sdc22_sensorboard_ping_pack(
    uint8_t *dst_p,
    const struct canlv_sdc22_sensorboard_ping_t *src_p,
    size_t size);

/**
 * Unpack message SENSORBOARD_PING.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int canlv_sdc22_sensorboard_ping_unpack(
    struct canlv_sdc22_sensorboard_ping_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t canlv_sdc22_sensorboard_ping_sensorboard_on_ack_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float canlv_sdc22_sensorboard_ping_sensorboard_on_ack_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool canlv_sdc22_sensorboard_ping_sensorboard_on_ack_is_in_range(uint8_t value);

/**
 * Pack message DASH_TIMER.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int canlv_sdc22_dash_timer_pack(
    uint8_t *dst_p,
    const struct canlv_sdc22_dash_timer_t *src_p,
    size_t size);

/**
 * Unpack message DASH_TIMER.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int canlv_sdc22_dash_timer_unpack(
    struct canlv_sdc22_dash_timer_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t canlv_sdc22_dash_timer_dash_seconds_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float canlv_sdc22_dash_timer_dash_seconds_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool canlv_sdc22_dash_timer_dash_seconds_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t canlv_sdc22_dash_timer_dash_minutes_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float canlv_sdc22_dash_timer_dash_minutes_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool canlv_sdc22_dash_timer_dash_minutes_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t canlv_sdc22_dash_timer_dash_hours_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float canlv_sdc22_dash_timer_dash_hours_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool canlv_sdc22_dash_timer_dash_hours_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t canlv_sdc22_dash_timer_dash_days_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float canlv_sdc22_dash_timer_dash_days_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool canlv_sdc22_dash_timer_dash_days_is_in_range(uint8_t value);

/**
 * Pack message DASH_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int canlv_sdc22_dash_status_pack(
    uint8_t *dst_p,
    const struct canlv_sdc22_dash_status_t *src_p,
    size_t size);

/**
 * Unpack message DASH_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int canlv_sdc22_dash_status_unpack(
    struct canlv_sdc22_dash_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t canlv_sdc22_dash_status_dash_on_ack_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float canlv_sdc22_dash_status_dash_on_ack_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool canlv_sdc22_dash_status_dash_on_ack_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t canlv_sdc22_dash_status_rtd_fsm_status_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float canlv_sdc22_dash_status_rtd_fsm_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool canlv_sdc22_dash_status_rtd_fsm_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t canlv_sdc22_dash_status_bms_led_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float canlv_sdc22_dash_status_bms_led_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool canlv_sdc22_dash_status_bms_led_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t canlv_sdc22_dash_status_nohv_led_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float canlv_sdc22_dash_status_nohv_led_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool canlv_sdc22_dash_status_nohv_led_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t canlv_sdc22_dash_status_imd_led_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float canlv_sdc22_dash_status_imd_led_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool canlv_sdc22_dash_status_imd_led_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t canlv_sdc22_dash_status_pwm_pump_ack_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float canlv_sdc22_dash_status_pwm_pump_ack_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool canlv_sdc22_dash_status_pwm_pump_ack_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t canlv_sdc22_dash_status_pwm_rad_fan_ack_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float canlv_sdc22_dash_status_pwm_rad_fan_ack_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool canlv_sdc22_dash_status_pwm_rad_fan_ack_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t canlv_sdc22_dash_status_pwm_bp_fan_ack_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float canlv_sdc22_dash_status_pwm_bp_fan_ack_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool canlv_sdc22_dash_status_pwm_bp_fan_ack_is_in_range(uint8_t value);

/**
 * Pack message DSPACE_DASH_TIMER.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int canlv_sdc22_dspace_dash_timer_pack(
    uint8_t *dst_p,
    const struct canlv_sdc22_dspace_dash_timer_t *src_p,
    size_t size);

/**
 * Unpack message DSPACE_DASH_TIMER.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int canlv_sdc22_dspace_dash_timer_unpack(
    struct canlv_sdc22_dspace_dash_timer_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t canlv_sdc22_dspace_dash_timer_cmd_count0_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float canlv_sdc22_dspace_dash_timer_cmd_count0_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool canlv_sdc22_dspace_dash_timer_cmd_count0_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t canlv_sdc22_dspace_dash_timer_cmd_count1_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float canlv_sdc22_dspace_dash_timer_cmd_count1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool canlv_sdc22_dspace_dash_timer_cmd_count1_is_in_range(uint8_t value);


#ifdef __cplusplus
}
#endif

#endif
